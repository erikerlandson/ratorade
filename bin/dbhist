#!/bin/env python

# ratorade: Everyone's a critic
#
# Copyright (c) 2012 Erik Erlandson
#
# Author:  Erik Erlandson <erikerlandson@yahoo.com>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import sys
import time
import argparse
import pymongo

import ratorade
import dbutils
import argparse_utils

argparser = argparse.ArgumentParser(parents=[dbutils.parser])
argparser.add_argument('collection', metavar='<collection-name>', help='collection name')
argparser.add_argument('attributes', nargs='+', metavar='<attribute>', help='list of attributes: attr1 [attr2 ...]')
argparser.add_argument('-bin', nargs='*', default=[], type=argparse_utils.avpair, action=argparse_utils.append_avpair_dict, metavar='<avpair>', help='add a binning spec')
argparser.add_argument('-odelim', default="\t", metavar='<delimiter>', help='output col delimiter: def= tab')
argparser.add_argument('-kdelim', default=":", metavar='<delimiter>', help='histogram key delimiter: def= ":"')
argparser.add_argument('-ofile', type=argparse.FileType('w'), default=sys.stdout, metavar='<outputfile>', help='def= stdout')
argparser.add_argument('-sort', default='freq', metavar='<attr-name>', help='def= "freq" (autogenerated histogram frequency)')
argparser.add_argument('-ascending', dest='descending', default=True, action='store_false', help='def= off (descending order)')
argparser.add_argument('-descending', default=True, action='store_true', help='def= on')
argparser.add_argument('-cumulative', default=False, action='store_true', help='include cumulative: freq/prob')
argparser.add_argument('-counts', default=False, action='store_true', help='include counts: count/cfrac')
argparser.add_argument('-histname', default='_hist', metavar='<name>', help='histogram collection name: default= "_hist"')
argparser.add_argument('-retain', default=False, action='store_true', help='do not delete the histogram collection when finished')
argparser.add_argument('-where', type = argparse_utils.dict_expr, default={}, metavar='<query>', help='a query to narrow histogram collection')
argparser.add_argument('-sample', type=float, default=0, metavar='<S|F>', help='histogram a random sample size S or fraction F')

args = argparser.parse_args()

# we can do this if there's no ambiguity
if len(args.attributes) == 1  and  len(args.bin) == 1:
    if not args.bin[0].has_key('attr'):
        args.bin[0]['attr'] = args.attributes[0]

# Fill in any binning specifications and sanity check:
bins = {}
for e in args.bin:
    if not (set(e.keys()) <= set(['attr','bins','min','max'])):
        sys.stderr.write("bad binning args: %s\n" % (e))
        exit(1)
    if not e.has_key('attr'):
        sys.stderr.write("bad binning args: %s\n" % (e))
        exit(1)        
    if e['attr'] not in args.attributes:
        sys.stderr.write("bad binning args: %s\n" % (e))
        exit(1)
    if not e.has_key('bins'):
        args.bin[0]['bins'] = 10
    bins[e['attr']] = e


if args.descending: sortdir = pymongo.DESCENDING
else:               sortdir = pymongo.ASCENDING


mongo = dbutils.require_connection(args.dbserver)
mongo_db = dbutils.require_db(mongo, args.dbname)
collection = dbutils.require_collection(mongo_db, args.collection)

where_attr = dbutils.query_attributes(args.where)
for k in where_attr:
    collection.ensure_index([(k, pymongo.ASCENDING)])

# compute the histogram
hist = ratorade.histogram_to_collection(collection, args.attributes, args.histname, prob=True, cumulative=args.cumulative, counts=args.counts, sortkey=args.sort, sortdir=sortdir, bins=bins, where=args.where, sample=args.sample)

# header
args.ofile.write("%s" % (args.kdelim.join(args.attributes)))
args.ofile.write("%sfreq%sprob" % (args.odelim, args.odelim))
if (args.cumulative): args.ofile.write("%scfreq%scprob" % (args.odelim, args.odelim))
if (args.counts): args.ofile.write("%scount%scfrac" % (args.odelim, args.odelim))
args.ofile.write("\n")

# dump the histogram data:
for e in hist.find().sort([(args.sort, sortdir)]):
    key = args.kdelim.join([str(e['_id'][k]) for k in args.attributes])
    oline = key
    oline += "%s%d%s%.4g" % (args.odelim, int(e['freq']), args.odelim, e['prob'])
    if args.cumulative: oline += "%s%d%s%.4g" % (args.odelim, int(e['cfreq']), args.odelim, e['cprob'])
    if args.counts: oline += "%s%d%s%.4g" % (args.odelim, int(e['count']), args.odelim, e['cfrac'])
    oline += "\n"
    args.ofile.write(oline)

# clear the histogram collection:
if not args.retain: hist.drop()
