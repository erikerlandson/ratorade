#!/bin/env python

# ratorade: Everyone's a critic
#
# Copyright (c) 2012 Erik Erlandson
#
# Author:  Erik Erlandson <erikerlandson@yahoo.com>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import sys
import time
import argparse
import pymongo

import ratorade

argparser = argparse.ArgumentParser()
argparser.add_argument('collection', metavar='<collection-name>', help='collection name')
argparser.add_argument('attributes', metavar='<attribute-list>', help='list of attributes: attr1[,attr2,...]')
argparser.add_argument('-numeric', default=False, action='store_true', help='treat histogramming attribute as numeric')
argparser.add_argument('-bins', type=int, default=0, metavar='<N>', help='histogram on numeric attribute using N bins: def= raw vals')
argparser.add_argument('-min', type=float, default=None, metavar='<X>', help='use X as numeric binning min')
argparser.add_argument('-max', type=float, default=None, metavar='<X>', help='use X as numeric binning max')
argparser.add_argument('-dbname', default='ratorade', metavar='<name>', help='rating db name: def="ratorade"')
argparser.add_argument('-dbserver', default='127.0.0.1', metavar='<db-server-ip>', help='def=127.0.0.1')
argparser.add_argument('-odelim', default="\t", metavar='<delimiter>', help='output col delimiter: def= tab')
argparser.add_argument('-kdelim', default=":", metavar='<delimiter>', help='histogram key delimiter: def= ":"')
argparser.add_argument('-ofile', type=argparse.FileType('w'), default=sys.stdout, metavar='<outputfile>', help='def= stdout')
argparser.add_argument('-sortkey', default=None, metavar='<attr-name>', help='def= "freq" (autogenerated histogram frequency)')
argparser.add_argument('-ascending', dest='descending', default=None, action='store_false', help='def= off (descending order)')
argparser.add_argument('-descending', default=None, action='store_true', help='def= on')
argparser.add_argument('-cumulative', default=False, action='store_true', help='include cumulative: freq/prob')
argparser.add_argument('-counts', default=False, action='store_true', help='include counts: count/cfrac')

args = argparser.parse_args()

attrlist=args.attributes.split(',')

if args.bins > 0: args.numeric = True
if args.numeric and (len(attrlist) > 1):
    sys.stderr.write("only one numeric attribute is allowed\n")
    exit(1)

if args.sortkey is None:
    if args.numeric: args.sortkey = attrlist[0]
    else:            args.sortkey = 'freq'

if args.descending is None:
    if args.numeric: args.descending = False
    else:            args.descending = True

mongo = ratorade.require_connection(args.dbserver)
mongo_db = ratorade.require_db(mongo, args.dbname)
collection = ratorade.require_collection(mongo_db, args.collection)

# group() has a mysterious limit of 20000 unique keys:
#gres = collection.group(attrlist, None, {'freq':0}, 'function(obj, prev) {prev.freq += 1}')

# a version using map-reduce:
gres = ratorade.histogram(collection, attrlist, "_hist", kdelim=args.kdelim, numeric=args.numeric, bins=args.bins, kmin=args.min, kmax=args.max).find()
if not args.numeric:
    gres = [dict(zip(attrlist,str(e['_id']).split(args.kdelim)) + [('freq',e['value'])]) for e in gres]
else:
    gres = [dict([(attrlist[0], e['_id']), ('freq', e['value'])]) for e in gres]

# order results prior to doing any cumulative stats:
gsort = sorted(gres, key=lambda D:D[args.sortkey], reverse=args.descending)

# sum of frequencies:
tfreq = 0
for e in gsort: tfreq += e['freq']

# compute prob and any cumulative stats:
cfreq = 0
count = 0
ctot = len(gsort)
for e in gsort:
    freq = e['freq']
    e['prob'] = float(freq)/float(tfreq)
    if args.cumulative:
        cfreq += freq
        e['cfreq'] = cfreq
        e['cprob'] = float(cfreq)/float(tfreq)
    if args.counts:
        count += 1
        e['count'] = count
        e['cfrac'] = float(count)/float(ctot) 

# header
args.ofile.write("key%sfreq%sprob" % (args.odelim, args.odelim))
if (args.cumulative): args.ofile.write("%scfreq%scprob" % (args.odelim, args.odelim))
if (args.counts): args.ofile.write("%scount%scfrac" % (args.odelim, args.odelim))
args.ofile.write("\n")

# dump the actual data:
for e in gsort:
    if args.numeric:
        key = str(e[attrlist[0]])
    else:
        key = args.kdelim.join([e[k] for k in attrlist])
    oline = key
    oline += "%s%d%s%.4g" % (args.odelim, int(e['freq']), args.odelim, e['prob'])
    if args.cumulative: oline += "%s%d%s%.4g" % (args.odelim, int(e['cfreq']), args.odelim, e['cprob'])
    if args.counts: oline += "%s%d%s%.4g" % (args.odelim, int(e['count']), args.odelim, e['cfrac'])
    oline += "\n"
    args.ofile.write(oline)
