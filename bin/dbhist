#!/bin/env python

# ratorade: Everyone's a critic
#
# Copyright (c) 2012 Erik Erlandson
#
# Author:  Erik Erlandson <erikerlandson@yahoo.com>
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import sys
import time
import argparse
import pymongo

import ratorade

argparser = argparse.ArgumentParser()
argparser.add_argument('collection', metavar='<collection-name>', help='collection name')
argparser.add_argument('attributes', metavar='<attribute-list>', help='list of attributes: attr1[,attr2,...]')
argparser.add_argument('-bin', nargs='*', default=[], action='append', help='add a binning spec')
argparser.add_argument('-dbname', default='ratorade', metavar='<name>', help='rating db name: def="ratorade"')
argparser.add_argument('-dbserver', default='127.0.0.1', metavar='<db-server-ip>', help='def=127.0.0.1')
argparser.add_argument('-odelim', default="\t", metavar='<delimiter>', help='output col delimiter: def= tab')
argparser.add_argument('-kdelim', default=":", metavar='<delimiter>', help='histogram key delimiter: def= ":"')
argparser.add_argument('-ofile', type=argparse.FileType('w'), default=sys.stdout, metavar='<outputfile>', help='def= stdout')
argparser.add_argument('-sort', default='freq', metavar='<attr-name>', help='def= "freq" (autogenerated histogram frequency)')
argparser.add_argument('-ascending', dest='descending', default=True, action='store_false', help='def= off (descending order)')
argparser.add_argument('-descending', default=True, action='store_true', help='def= on')
argparser.add_argument('-cumulative', default=False, action='store_true', help='include cumulative: freq/prob')
argparser.add_argument('-counts', default=False, action='store_true', help='include counts: count/cfrac')
argparser.add_argument('-histname', default='_hist', metavar='<name>', help='histogram collection name: default= "_hist"')
argparser.add_argument('-retain', default=False, action='store_true', help='do not delete the histogram collection when finished')
argparser.add_argument('-where', default='{}', metavar='<query>', help='a query to narrow histogram collection')
argparser.add_argument('-sample', type=float, default=0, metavar='<S|F>', help='histogram a random sample size S or fraction F')

args = argparser.parse_args()

attrlist = args.attributes.split(',')

# Fill in any binning specifications:
bins = {}
if args.bin == [[]]:
    args.bin = [[attrlist[0]]]
for e in args.bin:
    if len(e) > 2  or  len(e) < 1:
        sys.stderr.write("bad binning args: %s\n" % (e))
        exit(1)
    if len(e) == 2:
        try:
            b = eval(e[1])
        except:
            sys.stderr.write("bad binning args: %s\n" % (e))
            exit(1)
    else:
        b = 10
    if type(b) == int:
        b = {'bins': b}
    elif type(b) == dict:
        pass
    else:
        sys.stderr.write("bad binning args: %s\n" % (e))
        exit(1)
    if not (set(b.keys()) <= set(['bins','min','max'])):
        sys.stderr.write("bad binning args: %s\n" % (e))
        exit(1)
    for k in b.keys():
        if type(b[k]) not in [int, float]:
            sys.stderr.write("bad binning args: %s\n" % (e))
            exit(1)
    if e[0] not in attrlist:
        sys.stderr.write("bad binning args: %s\n" % (e))
        exit(1)
    bins[e[0]] = b


if args.descending: sortdir = pymongo.DESCENDING
else:               sortdir = pymongo.ASCENDING

try:
    where_expr = eval(args.where)
except:
    sys.stderr.write("bad where expr %s\n" % (args.where))
    exit(1)
if type(where_expr) != dict:
    sys.stderr.write("bad where expr %s\n" % (args.where))
    exit(1)


mongo = ratorade.require_connection(args.dbserver)
mongo_db = ratorade.require_db(mongo, args.dbname)
collection = ratorade.require_collection(mongo_db, args.collection)

where_attr = ratorade.query_attributes(where_expr)
for k in where_attr:
    collection.ensure_index([(k, pymongo.ASCENDING)])

# compute the histogram
hist = ratorade.histogram_to_collection(collection, attrlist, args.histname, prob=True, cumulative=args.cumulative, counts=args.counts, sortkey=args.sort, sortdir=sortdir, bins=bins, where=where_expr, sample=args.sample)

# header
args.ofile.write("key%sfreq%sprob" % (args.odelim, args.odelim))
if (args.cumulative): args.ofile.write("%scfreq%scprob" % (args.odelim, args.odelim))
if (args.counts): args.ofile.write("%scount%scfrac" % (args.odelim, args.odelim))
args.ofile.write("\n")

# dump the histogram data:
for e in hist.find().sort([(args.sort, sortdir)]):
    key = args.kdelim.join([str(e['_id'][k]) for k in attrlist])
    oline = key
    oline += "%s%d%s%.4g" % (args.odelim, int(e['freq']), args.odelim, e['prob'])
    if args.cumulative: oline += "%s%d%s%.4g" % (args.odelim, int(e['cfreq']), args.odelim, e['cprob'])
    if args.counts: oline += "%s%d%s%.4g" % (args.odelim, int(e['count']), args.odelim, e['cfrac'])
    oline += "\n"
    args.ofile.write(oline)

# clear the histogram collection:
if not args.retain: hist.drop()
